\section{Introduzione}

% TODO disegno albero TD BU pag 53.2
Il problema del memorylessness del paradigma \emph{Divide and Conquer} è già stato sottolineato nella sezione \ref{sss:alberochiamate}.
Per esemplificare il problema, si introduce la sequnza di Fibonacci, definita come
\begin{equation*}
    F_n = 
    \begin{cases}
        1 & n=0,1 \\
        F_{n-1} + F_{n-2} & n>1
    \end{cases}
\end{equation*}
da cui si ricava immediatamente un algoritmo ricorsivo
\begin{algorithm}[H]
\caption{Fibonacci ricorsivo}\label{alg:rfib}
\begin{algorithmic}[1]
    \Procedure{R\_FIB}{$n$}
        \If{$ n=0 $ or $n=1$}
            \State return $1$
        \EndIf
        \State return \Call{R\_FIB}{$n-1$} + \Call{R\_FIB}{$n-2$}
    \EndProcedure
\end{algorithmic}
\end{algorithm}
% TODO disegno albero chiamate R_FIB pag 53.4
\noindent
la cui equazione di ricorrenza è
\begin{equation*}
    T_{RF}(n) = 
    \begin{cases}
        0 & n=0,1 \\
        T_{RF}(n-1) + T_{RF}(n-2) + 1 & n>1
    \end{cases}
\end{equation*}
che risulta limitata inferiormente da un esponenziale, infatti per $n>1$
\begin{align*}
    T_{RF}(n) 
    &= T_{RF}(n-1) + T_{RF}(n-2) + 1 \\
    & \geq \, 2 T_{RF}(n-2) + 1 \\
    & \geq \, 2^2 T_{RF}(n-2-2) + 2 + 1 \\
    & \geq \, 2^i T_{RF}(n-2i) + \sum_{j=0}^{i-1} 2^j \\
    \intertext{che raggiunge il caso base quando $n-2i=0$ o $n-2i=1$ per $i= \left\lfloor n/2 \right\rfloor $ sia nel caso di $n$ pari sia nel caso di $n$ dispari}
    & \geq \, 2^{\left\lfloor n/2 \right\rfloor} \cancel{ T_{RF}(0 \text{ o } 1)}
    + \sum_{j=0}^{\left\lfloor n/2 \right\rfloor -1} 2^j \\
    &= 2^{\left\lfloor n/2 \right\rfloor} -1 \\
    &=  \Omega \left( 2^{n/2} \right) = \sqrt{2}^{\,n}
    \intertext{ed essendo $\sqrt{2}>1$ cresce più velocemente di ogni polinomio. Il valore esatto di $T_{RF}$ è}
    T_{RF}(n) &= \Theta \left( \left( \frac{1+\sqrt{5}}{2} \right)^n \right)
\end{align*}

Il sugo della storia è che viene calcolata un numero molto elevato di volte la stessa sottoistanza. Ispirandosi alla fase \emph{Bottom-Up} del \emph{D\&C}, e sfruttando strutture dati che contengano le informazioni necessarie, si può scrivere un algoritmo iterativo che risolve il problema.
\begin{algorithm}[H]
\caption{Fibonacci iterativo}\label{alg:itfib}
\begin{algorithmic}[1]
    \Procedure{IT\_FIB}{$n$}
        \If{$ n=0 $ or $n=1$}
            \State return $1$
        \EndIf
        \State $F[0] \gets 1$
        \State $F[1] \gets 1$
        \For{$i \gets 2 $ to $ n $ } 
            \State $F[i] \gets F[i-1] + F[i-2]$
        \EndFor
        \State return $F[n]$
    \EndProcedure
\end{algorithmic}
\end{algorithm}
\noindent
dove le soluzioni intermedie sono salvate in $F$. In realtà sarebbe sufficiente memorizzare solo gli ultimi due valori della sequenza.

Si può quindi introdurre il paradigma del \emph{Dynamic Programming}, basandosi su queste osservazioni.

\subsection{Paradigma del \emph{Dynamic Programming}}
% \subsection{Introduzione}
I due concetti fondamentali su cui si basa il paradigma \emph{Dynamic Programming} sono
\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
    \item[--] dotare di memoria l'algoritmo
    \item[--] implementare la computazione in direzione \emph{bottom-up} (tutti i dati necessari sono già stati calcolati nelle iterazioni precedenti)
\end{itemize}
In ogni caso si lavora con la proprietà di sottostruttura, generando la soluzione ad un'istanza in funzione di sottoistanze di taglia minore.

Il vantaggi sono una maggiore velocità dovuta al non replicare la computazione, gli svantaggi sono legati al dover implementare la computazione in maniera da essere sicuri di avere a disposizione le soluzioni necessarie al momento giusto, che per casi articolati non è triviale. Si può sfruttare la convenienza della fase \emph{top-down}, che genera e risolve le istanze in modo coerente, scrivendo l'algoritmo in maniera ricorsiva e dotandolo di memoria, come descritto nella sezione seguente.

\subsection{Memoizzazione di un algoritmo ricorsivo}

È possibile modificare un algoritmo ricorsivo \emph{D\&C} memorizzando le soluzioni intermedie attraverso un processo di memoizzazione.

\subsubsection{Metodo generale}

Un algoritmo memoizzato è costituito da due subroutine:
\begin{enumerate}
    \item \textbf{Routine di inizializzazione} INIT\_\{AlgName\}
        \begin{itemize}
            \item risolve i casi di base direttamente
            \item inizializza una struttura tabellare \emph{globale} con
                \begin{itemize}
                    \item valori delle istanze di base, nelle locazioni associate alle istanze di base
                    \item valori di default in posizioni associate a istanze non di base (il valore di default deve essere scelto in modo da far capire che non è stato ancora calcolato)
                \end{itemize}
            \item invoca la seconda procedura (ricorsiva) \\ % FORMATTA
        \end{itemize}
    \item \textbf{Routine ricorsiva} REC\_\{AlgName\}($i$)
        \begin{itemize}
            \item controlla sulla tabella per vedere se $i$ è già stata risolta
                \begin{itemize}
                    \item se sì la ritorna
                    \item se no
                        \begin{itemize}
                            \item la calcola con la proprietà di sottostruttura
                            \item la memorizza nella tabella
                            \item la ritorna
                        \end{itemize}
                \end{itemize}
        \end{itemize}
\end{enumerate}

\textbf{Nota:} lo spazio delle sottoistanze deve essere 
\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
    \item[--] piccolo
    \item[--] facilmente indicizzabile
\end{itemize}

\subsubsection{Algoritmo di Fibonacci memoizzato}

Per l'algoritmo di Fibonacci le due funzioni risultano
\begin{algorithm}[H]
\caption{Fibonacci memoizzato}\label{alg:fibmemoizzato}
\begin{algorithmic}[1]
    \Procedure{INIT\_FIB}{$n$}
        \If{$ n=0 $ or $n=1$}
            \State return $1$
        \EndIf
        \State $F[0] \gets 1$, $F[1] \gets 1$
        % \State $F[1] \gets 1$
        \For{$i \gets 2 $ to $ n $ } 
            \State $F[i] \gets 0$
        \EndFor
        \State return \Call{REC\_FIB}{$n$}
    \EndProcedure
    \Procedure{REC\_FIB}{$n$}
        \If{$F[i] = 0$}
            \State $F[i] \gets \Call{REC\_FIB}{i-1} + \Call{REC\_FIB}{i-2} $
        \EndIf
        \State return $F[i]$
    \EndProcedure
\end{algorithmic}
\end{algorithm}
Note:
$n$ è un parametro attuale, il valore che si vuole calcolare, mentre $i$ è un parametro formale, che descrive la generica sottoistanza su cui lavora l'algoritmo ricorsivo.
Nella funzione ricorsiva si testa se la struttura tabellare contiene già la soluzione della sottoistanza, e se no lo si calcola con l'algoritmo ricorsivo e lo si salva. Nelle successive chiamate il test fallisce e non è necessario calcolare nuovamente il valore.
Il \emph{caveat} nel dare memoria a un algoritmo \emph{D\&C} è che in lo spazio delle sottoistanze deve essere molto piccolo, in questo caso una sola sottoistanza per ogni valore di $n$. Inoltre perché l'algoritmo sia efficiente lo spazio delle possibili sottoistanze da risolvere deve essere facilmente indirizzabile e salvabile in una struttura dati semplici.

Analisi della complessità:
La ricorrenza non riesce a catturare il fatto che l'albero delle chiamate venga tagliato ogniqualvolta il valore di una sottoistanza sia stato calcolato precedentemente.
% TODO albero delle chiamate memoizzato pag 55.9
Per la fase di inizializzazione, il numero di operazioni aritmetiche che vengono eseguite è nullo.
Dall'albero delle chiamate della procedura ricorsiva con memoria, si nota che l'albero è diventato molto più snello, e sono comparse foglie dove prima erano presenti sottoalberi. Inoltre il numero di nodi interni, gli unici rispetto a cui viene fatto lavoro, sono pari al numero di sottoistanze \emph{distinte} che vanno risolte per ottenere l'istanza $n$. 
Solo nel nodo interno si esegue il conquer (la somma) associato ad ogni chiamata e la complessità sarà corrispondente al numero di nodi interni per il lavoro compiuto in ciascun nodo. C'è un nodo interno per ogni chiamata \emph{non} di base, tutte le altre sono chiamate che hanno trovato il valore in $F$ e non hanno compiuto lavoro, se non un \emph{lookup} nella tabella.
\begin{equation*}
    T_{RF} (n) = n-2+1 = n-1
\end{equation*}

\section{Paradigma generale \emph{Dynamic Programming}}

\subsection{Problemi di ottimizzazione combinatoria}

Ricordiamo la definizione di problema computazionale $\bpi{} \subseteq \bi{} \times \bs{}$

Si può definire per ogni istanza un sottoinsieme $\bs{}(i)$ formato da tutte le possibili soluzioni di quell'istanza, ricordando che una sottoistanza può ammetere più soluzioni.
\begin{equation*}
    \forall i \in \bs{} \quad S(i) = \left\{ s \in \bs{} : i \, \bpi{} \, s \right\}
\end{equation*}

Definiamo inoltre una funzione di costo che va da S in un qualche insieme totalmente ordinato.
\begin{equation*}
    c : \bs{} \to \mathbb{R}
\end{equation*}

Data $i$ un istanza generica, si vuole determinare non solo una soluzione $s \in \bs{}(i)$, ma individuare $s^*$ che massimizza (o minimizza) il criterio del costo.
\begin{equation*}
    c(s^*) = \max \left\{ c(s) : s \in \bs{}(i) \right\}
\end{equation*}

\subsection{Caratteristiche di problemi di ottimizzazione risolubili con la programmazione dinamica}

Un problema si presta ad essere risolto con la programamzione dinamica se presenta la seguente proprietà di sottostruttura ottima, che per un prolbema di ottimizzazione è una proprietà molto più ristretta rispetto a quella necessaria per il \emph{D\&C}. Infatti mette in relazione soluzioni ottime di un istanza a soluzioni ottime di sottoistanze. Questa proprietà si dice anche \emph{optimal substructure property}.

% Dare paradigmi generali che si applicano quando un problema va approcciato con la programamzione dinamica.

% Come nel dnc si sviluppa una proprietà di sottostruttura, possiamo seguire una serie di indicazioni generali che si possono istanziare volta per volta che conducono in maniera ordinata alla risuluzone di un problema con la prog dinanica. 

% Quando si decide di usare la prog dinamica?

\begin{definition}[Proprietà di sottostruttura ottima]
    Un problema gode della proprietà di sottostruttura ottima se
    \begin{enumerate}
        \item la soluzione ottima di un'istanza non di base si ottiene combinando soluzioni ottime di sottoistanze
        \item la proprietà di sottostruttura ottima genera sottoproblemi ripetuti
        \item lo spazio delle sottoistanze generate da una data istanza non è troppo grande
    \end{enumerate}
\end{definition}

Se la proprietà 2 manca, si può applicare il \emph{D\&C} classico e la programamzione dinamica non aiuterebbe.
La proprietà 3 assicura l'efficienza del paradigma, il concetto è arbitrario per ora, se non esiste una struttura dati che riesca a memorizzare in maniera efficiente i risultati intermedi, il metodo avrà risultati peggiori. In genere la dimensionalità della struttura è pari al numero di sottoistanze generate (e.g. istanze di taglia $|i|=n$ generano $n^2$ sottoistanze salvate in un array bidimensionale ).

\subsection{Paradigma generale}

Presentiamo un paradigma generale per la programmazione dinamica.
Passi da seguire per sviluppare un programma secondo il \emph{dynamic programming}, garantendo che il codice sia corretto.

\begin{enumerate}
    \item caratterizza la struttura di una soluzione ottima $s^*$ a un'istanza $i$ non di base in funzione di soluzioni ottime $s_1^*, s_2^*, \cdots, s_k^*$ di sottoistanze di $i$
    \item
        \begin{enumerate}
            \item determina una relazione di ricorrenza sui costi di istanza e sottoistanza, mettendo in relazione il costo di un'istanza come una funzione dei costi delle sottoistanze \\ $c(s^*)=f\left(c(s_1^*),c(s_2^*),\cdots,c(s_k^*)\right)$
                \label{enum:pd1}
            \item determina la minima informazione strutturale necessaria ad ottenere $s^*$ a partire da $s_1^*, s_2^*, \cdots, s_k^*$, cercando di memorizzare incrementi, e non le intere soluzioni di sottoistanze
                \label{enum:pd2}
        \end{enumerate}
    \item
        \begin{enumerate}
            \item calcola il costo $c(s^*)$ utilizzando la ricorrenza impostando la computazione
                \begin{itemize}
                    \item in maniera \emph{bottom-up} iterativa
                    \item in maniera memoizzata
                \end{itemize}
                \label{enum:pd3}
            \item calcola l'informazione addizionale strutturale per ottenere $s^*$ e memorizzarla
                \label{enum:pd4}
        \end{enumerate}
\end{enumerate}

I punti \ref{enum:pd2}, \ref{enum:pd4} sono necessari solo quando si è interessati anche alla soluzione ottima, mentre \ref{enum:pd1}, \ref{enum:pd3} forniscono solo il costo della soluzione ottimale.

\subsection{autocomplete}
Una bella scatola:
\begin{equation}
    \boxed{x^2+y^2 = z^2}
\end{equation}

Numeri nei casi
\begin{numcases}{T(n)=}
    2^3 \label{escaso1} \\
    2^4 \label{escaso2} 
\end{numcases}

Sotto numeri
\begin{subnumcases}{T(n)=}
    2^3 \label{escaso3} \\
    2^4 
\end{subnumcases}

\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
    \item qualcosa
    \item[+] qualcosa
    \item[*] qualcosa
    \item[--] qualcosa
\end{itemize}
àg
èg
ìg
òg
ùg
perché

delirio di vim se scrivi \verb|<C-k>`e| o \verb|<C-k>e`| in insert mode mette una è

% delirio doppio di vim se scrivi \verb|<C-k>da| in insert mode mette ``Hiragana letter DA'' che purtroppo non posso mostrarvi %だ
% insomma i digraph sono tanti e belli

Spazietti fra equazioni
\begin{equation*}
    A^{[0]}(x) = \sum_{j=0}^{\frac{n}{2}-1} a_{2j}x^j
    \quad \text{ e } \quad
    A^{[1]}(x) = \sum_{j=0}^{\frac{n}{2}-1} a_{2j+1}x^j
\end{equation*}

Un gustoso algoritmo
\begin{algorithm}[H]
\caption{Divide and Conquer}\label{alg:dncmock}
\begin{algorithmic}[1]
    \Procedure{D\&C}{$i$}
        \If{$|i| \leq n_0$}                             \Comment{BASE}
            \State *risolvo direttamente*
        \EndIf
        \State $<i_1, i_2, \dots, i_k> \gets A_D(i)$    \Comment{DIVIDE}
        \For{$j \gets 1 $ to $ k $ }                    \Comment{RECURSE}
            \State $s_j \gets $ \Call{D\&C}{$i_j$}
        \EndFor
        \State $s \gets A_C(<s_1, s_2, \dots, s_k>)$    \Comment{CONQUER}
        \State return $s$
    \EndProcedure
\end{algorithmic}
\end{algorithm}



