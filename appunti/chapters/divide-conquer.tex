\section{Paradigma divide and conquer}

Seguendo il paradigma \textit{Divide and Conquer}, si cerca una soluzione ad una data istanza in funzione delle soluzioni a determinate istanze \textbf{più piccole}, dette sottoistanze.

\subsection{Stella di Kleene}
\begin{definition}[Stella di Kleene]\label{def:kleene}
    La stella di Kleene viene definita come l'insieme di tutte le sequenze finite di elementi di $A$.
    $$ A^* = \left\{ < a_1, a_2, \dots, a_k > \: : k \geq 0, \: a_i \in A, \: 1 \leq i \leq k \right\}$$
    La sequenza vuota viene indicata con $ < \; > \: = \epsilon $
\end{definition}

\subsection{Proprietà di sottostruttura}

La proprietà di sottostruttura è una proprietà del problema $\bpi{} \subseteq \bi{} \times \bs{} $ che permette di definire il divide and conquer. Devono esistere due funzioni per avere la proprietà di sottostruttura:

\begin{description}
    \item{Funzione di \textbf{Divisione}} $ D : \bi{} \to \bi{}^*$
    \item{Funzione di \textbf{Ricombinazione}} $ C : \bs{}^* \to \bs{}$
\end{description}

E devono valere le due seguenti proprietà:
\begin{itemize}
    \item $\exists n_0 \in \mathbb{N} \cup \{0\} : \forall i \in \bi{}, |i| > n_0 $
        \begin{itemize}
            \item[--] $ D(i)=<i_1, i_2, \dots, i_k>:|i_j|<|i|, 1 \leq j \leq k$ \\
                (le sottoistanze sono strettamente più piccole dell'istanza originale)
            \item[--] data $ <s_1, s_2, \dots, s_k> \in \bs{}^* $ con $i_j \bpi{} s_j,  1 \leq j \leq k \Rightarrow i \bpi{} C(<s_1, s_2, \dots, s_k>)$ \\
                (la ricombinazione delle soluzioni alle sottoistanze è in relazione con l'istanza originale)
        \end{itemize}
    \item è possibile la risoluzione diretta delle istanze $ i \in \bi{} : |i| \leq n_0 $
\end{itemize}

Note:
% \begin{itemize}
\begin{itemize}[noitemsep,parsep=0pt,partopsep=0pt]
    \item[--] il numero di sottoistanze può variare, in base all'istanza considerata
    \item[--] gli algoritmi che implementano (con sequenze di istruzioni elementari) le funzioni, sono, formalmente, oggetti matematici diversi \\
        $ A_D : i \mapsto <i_1, i_2, \dots, i_k> \sim D(i)$ e $ A_C : <s_1, s_2, \dots, s_k> \mapsto s \sim C(<s_1, s_2, \dots, s_k>) $
\end{itemize}

\subsubsection{Problema del Sorting di interi - definizione}

Introduciamo il problema dell'ordinamento di una sequenza di numeri interi, che verrà usato anche in seguito per esemplificare i concetti teorici esposti.

Come insiemi definiamo $\bi{} = \mathbb{Z}^* $ e $\bs{} = \mathbb{Z}^* $. Non tutti gli elementi di $\bs{}$ saranno associati ad un'istanza.

Quando $ (i,s) \in \bpi{}_{SORT} $ ? A parte il caso degenere $i=s=\epsilon$, deve esistere una corrispondenza biunivoca fra gli indici per cui
\begin{itemize}[noitemsep,parsep=0pt,partopsep=0pt]
    \item[--] $i = <i_1, i_2, \dots, i_k> $ e $ s = <s_1, s_2, \dots, s_k> $ con $k \geq 1$
    \item[--] $ \exists \;\phi:\{1, \dots, n\} \leftrightarrow \{1, \dots, n\} \;|\; s_i = i_{\phi(i)}$
    \item[--] $ s_1 \leq s_2 \leq \dots \leq s_k$ 
\end{itemize}

\subsection{Paradigma Divide and Conquer}

\begin{algorithm}[H]
\caption{Divide and Conquer}\label{alg:dnc}
\begin{algorithmic}[1]
    \Procedure{D\&C}{$i$}
        \If{$|i| \leq n_0$}                             \Comment{BASE}
            \State *risolvo direttamente*
        \EndIf
        \State $<i_1, i_2, \dots, i_k> \gets A_D(i)$    \Comment{DIVIDE}
        \For{$j \gets 1 $ to $ k $ }                    \Comment{RECURSE}
            \State $s_j \gets $ \Call{D\&C}{$i_j$}
        \EndFor
        \State $s \gets A_C(<s_1, s_2, \dots, s_k>)$    \Comment{CONQUER}
        \State return $s$
    \EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Albero delle chiamate}
Nel corso del D\&C, si alternano chiamate all'algoritmo di Divide, e quindi una fase di espansione, generazione \textit{top-down} delle sottoistanze, e chiamate all'algoritmo di Conquer, associato a fasi di contrazione, risoluzione \textit{bottom-up}. L'albero non viene generato tutto contemporaneamente, ma viene creato (e distrutto) nel corso dell'algoritmo, seguendo il cammino di una visita anticipata (\textit{depth-first search}).

Il fatto che nella fase di Conquer venga eliminata la porzione di albero generato per risolvere una sottoistanza, è uno dei difetti principali di questo paradigma. Il non ricordare le soluzioni parziali trovate lo rende un processo computazionale \textit{memoryless}.

TODO pagina 4, albero delle chiamate, disegnini e grafichetti

\subsubsection{Esempio algoritmo D\&C, ricerca del massimo}

Come esempio di algoritmo D\&C, viene presentata una procedura che trova il massimo intero in una sequenza di interi $A[1 \dots n] \in \mathbb{Z}^*$

\begin{algorithm}[H]
\caption{Massimo}\label{alg:max}
\begin{algorithmic}[1]
    \Procedure{MAX}{$A,i,j$}                            
        \If{$i=j$}                             \Comment{BASE}
            \State return $A[i]$
        \EndIf
        \State $k \gets \left\lfloor \frac{i+j}{2} \right\rfloor$    \Comment{DIVIDE - punto di mezzo discreto}
        \State $m_1 \gets $ \Call{MAX}{$A,i,k$} \Comment{RECURSE}
        \State $m_1 \gets $ \Call{MAX}{$A,k+1,j$}
        \If{$m_1 \geq m_2$}              \Comment{CONQUER}
            \State return $m_1$
        \Else
            \State return $m_2$
        \EndIf
    \EndProcedure
\end{algorithmic}
\end{algorithm}

Nota: Nella firma della procedura, sono presenti tutti i parametri necessari a identificare la \textit{generica} sottostruttura

\subsection{Correttezza del DnC}

Induzione e magia

Relazione di ricorrenza

\subsection{Analisi della complessità}

\subsubsection{autocomplete}

Il \textit{merge}, cuore dell'algoritmo \ref{alg:mergesort}, avviene alla riga \ref{alg:mergeline}, quindi guarda a \algref{alg:mergesort}{alg:mergeline} per saperne di più.

\begin{algorithm}[h]
\caption{MergeSort}\label{alg:mergesort}
\begin{algorithmic}[1]
    \Procedure{MergeSort}{$A,p,r$}
    \If{$p<r$}
        \State $ q \gets \left\lfloor \frac{p+r}{2} \right\rfloor $ 
        \State \Call{MergeSort}{$A,p,q$} \Comment{Ordina prima}
        \State \Call{MergeSort}{$A,q+1,r$} \Comment{Ordina dopo}
        \State
            \Call{Merge}{$A,p,q,r$}
            \label{alg:mergeline}
            \Comment{Merge in $\Theta(n)$}
    \EndIf
    \EndProcedure
\end{algorithmic}
\end{algorithm}

àg
èg
òg
ùg
