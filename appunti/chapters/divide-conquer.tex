\section{Paradigma divide and conquer}

Seguendo il paradigma \textit{Divide and Conquer}, si cerca una soluzione ad una data istanza in funzione delle soluzioni a determinate istanze \textbf{più piccole}, dette sottoistanze.

\subsection{Stella di Kleene}
\begin{definition}[Stella di Kleene]\label{def:kleene}
    La stella di Kleene viene definita come l'insieme di tutte le sequenze finite di elementi di $A$.
    $$ A^* = \left\{ < a_1, a_2, \dots, a_k > \: : k \geq 0, \: a_i \in A, \: 1 \leq i \leq k \right\}$$
    La sequenza vuota viene indicata con $ < \; > \: = \epsilon $
\end{definition}
\subsection{Proprietà di sottostruttura}

La proprietà di sottostruttura è una proprietà del problema $\bpi{} \subseteq \bi{} \times \bs{} $ che permette di definire il divide and conquer. Devono esistere due funzioni per avere la proprietà di sottostruttura:

\begin{description}
    \item{Funzione di \textbf{Divisione}} $ D : \bi{} \to \bi{}^*$
    \item{Funzione di \textbf{Ricombinazione}} $ C : \bs{}^* \to \bs{}$
\end{description}

E devono valere le due seguenti proprietà:
\begin{itemize}
    \item $\exists n_0 \in \mathbb{N} \cup \{0\} : \forall i \in \bi{}, |i| > n_0 $
        \begin{itemize}
            \item[--] $ D(i)=<i_1, i_2, \dots, i_k>:|i_j|<|i|, 1 \leq j \leq k$ \\
                (le sottoistanze sono strettamente più piccole dell'istanza originale)
            \item[--] data $ <s_1, s_2, \dots, s_k> \in \bs{}^* $ con $i_j \bpi{} s_j,  1 \leq j \leq k \Rightarrow i \bpi{} C(<s_1, s_2, \dots, s_k>)$ \\
                (la ricombinazione delle soluzioni alle sottoistanze è in relazione con l'istanza originale)
        \end{itemize}
    \item è possibile la risoluzione diretta delle istanze $ i \in \bi{} : |i| \leq n_0 $
\end{itemize}

Note:
% \begin{itemize}
\begin{itemize}[noitemsep,parsep=0pt,partopsep=0pt]
    \item[--] il numero di sottoistanze può variare, in base all'istanza considerata
    \item[--] gli algoritmi che implementano (con sequenze di istruzioni elementari) le funzioni, sono, formalmente, oggetti matematici diversi \\
        $ A_D : i \mapsto <i_1, i_2, \dots, i_k> \sim D(i)$ e $ A_C : <s_1, s_2, \dots, s_k> \mapsto s \sim C(<s_1, s_2, \dots, s_k>) $
\end{itemize}

TODO pagina 8, definizione del sorting di interi

\subsection{Paradigma Divide and Conquer}

\begin{algorithm}[H]
\caption{Divide and Conquer}\label{alg:dnc}
\begin{algorithmic}[1]
    \Procedure{D\&C}{$i$}
        \If{$|i| \leq n_0$}                     \Comment{BASE}
            \State *risolvo direttamente*
        \EndIf
        \State $<i_1, i_2, \dots, i_k> \gets A_D(i)$ \Comment{DIVIDE}
        \For{$j \gets 1 $ to $ k $ }                    \Comment{RECURSE}
            \State $s_j \gets $ \Call{D\&C}{$i_j$}
        \EndFor
        \State $s \gets A_C(<s_1, s_2, \dots, s_k>)$    \Comment{CONQUER}
        \State return $s$
    \EndProcedure
\end{algorithmic}
\end{algorithm}

TODO pagina 4, albero delle chiamate

TODO pagina 4, esempio algoritmo sorting di interi 

\subsection{Correttezza del DnC}

Induzione e magia

Relazione di ricorrenza

\subsection{Analisi della complessità}

\subsubsection{autocomplete}

Il \textit{merge}, cuore dell'algoritmo \ref{alg:mergesort}, avviene alla riga \ref{alg:mergeline}, quindi guarda a \algref{alg:mergesort}{alg:mergeline} per saperne di più.

\begin{algorithm}[h]
\caption{MergeSort}\label{alg:mergesort}
\begin{algorithmic}[1]
    \Procedure{MergeSort}{$A,p,r$}
    \If{$p<r$}
        \State $ q \gets \left\lfloor \frac{p+r}{2} \right\rfloor $ 
        \State \Call{MergeSort}{$A,p,q$} \Comment{Ordina prima}
        \State \Call{MergeSort}{$A,q+1,r$} \Comment{Ordina dopo}
        \State
            \Call{Merge}{$A,p,q,r$}
            \label{alg:mergeline}
            \Comment{Merge in $\Theta(n)$}
    \EndIf
    \EndProcedure
\end{algorithmic}
\end{algorithm}

àg
èg
òg
ùg
